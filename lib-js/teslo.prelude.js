(function (teslo) { teslo.prelude = "(def defm (macro (name signature body) `(def ~name (macro ~signature ~body))))\n\n(defm defn (name . signatures) `(def ~name (fn ~@signatures)))\n\n(defm deft (tname . params) `(def ~tname (create-type (name '~tname) ~@params)))\n\n(defm do (. x) `((fn (. x) (last x)) ~@x))\n\n(defn identity (x) x)\n\n(defn inc (x) (+ x 1))\n\n(defn dec (x) (- x 1))\n\n(defn string ((k : Keyword)) (+ \":\" (name k))\n             ((s : Symbol))  (name s)\n             ((s : String))  (+ \"\\\"\" s \"\\\"\")\n             ((n : Number))  (+ n \"\")\n             ((l : List))    (+ \"(\" (join (map string l) \" \") \")\")\n             ((a : Array))   (+ \"(\" (join (map string a) \" \") \")\")\n             (x)             (string* x string))\n\n(defn print (x) (log* (string x)))\n\n\n;; Lists\n\n(deft List ()\n           (head tail))\n\n(def nil (List))\n\n\n;; Sequences\n\n(defn first ((a : Array)) (array-first* a)\n            ((List h t)) h)\n\n(defn rest ((a : Array)) (array-rest* a)\n           ((List h t))  t\n           ((List))      nil)\n\n(defn last ((a : Array))     (array-last* a)\n           ((List h (List))) h\n           ((List h t))      (last t))\n\n(defn length ((a : Array)) (array-length* a)\n             ((List h t))  (+ 1 (length t))\n             ((List))      0)\n\n(defn map (f (List h t))  (List (f h) (map f t))\n          (f (List))      nil\n          (f (a : Array)) (match (array-length* a)\n                                 0    nil\n                                 else (let (h (first a)\n                                            t (rest a))\n                                        (List (f h) (map f t)))))\n\n(defn reduce (f a (List h t)) (reduce f (f a h) t)\n             (f a (List))     a)\n\n(defn join ((List h t) sep) (reduce (fn (a h*) (+ a sep h*)) h t)\n           ((List) sep) \"\")\n"; })(this.teslo || require('../'));